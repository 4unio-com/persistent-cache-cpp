<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>persistent-cache-cpp: core::PersistentStringCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">persistent-cache-cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcore_1_1PersistentStringCache.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcore_1_1PersistentStringCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">core::PersistentStringCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A cache of key-value pairs with persistent storage.  
 <a href="classcore_1_1PersistentStringCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="persistent__string__cache_8h_source.html">core/persistent_string_cache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple pair of value and metadata.  <a href="structcore_1_1PersistentStringCache_1_1Data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb41596aa15b942a0be9081dd654d555"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; <a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">UPtr</a></td></tr>
<tr class="separator:afb41596aa15b942a0be9081dd654d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acde7b9c4c9450bfe25379227e2e7ca78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#acde7b9c4c9450bfe25379227e2e7ca78">~PersistentStringCache</a> ()</td></tr>
<tr class="separator:acde7b9c4c9450bfe25379227e2e7ca78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copy and Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Cache instances are not copyable, but can be moved. </p><dl class="section note"><dt>Note</dt><dd>The constructors are private. Use one of the <a class="el" href="classcore_1_1PersistentStringCache.html#ac856ad6d54e1af71a10074a6bb57377d" title="Creates or opens a PersistentStringCache. ">open()</a> static member functions to create or open a cache. </dd></dl>
</div></td></tr>
<tr class="memitem:abae85940424012eeb9dcf18eba40f401"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#abae85940424012eeb9dcf18eba40f401">PersistentStringCache</a> (<a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> const &amp;)=delete</td></tr>
<tr class="separator:abae85940424012eeb9dcf18eba40f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2441b85e407b9188d38607974a6a995f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a2441b85e407b9188d38607974a6a995f">operator=</a> (<a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> const &amp;)=delete</td></tr>
<tr class="separator:a2441b85e407b9188d38607974a6a995f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01473e8dac6afc156d151dd70973d50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#ae01473e8dac6afc156d151dd70973d50">PersistentStringCache</a> (<a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&amp;)</td></tr>
<tr class="separator:ae01473e8dac6afc156d151dd70973d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b7ecf11b9954ffa0230769e1dda94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a5d8b7ecf11b9954ffa0230769e1dda94">operator=</a> (<a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&amp;)</td></tr>
<tr class="separator:a5d8b7ecf11b9954ffa0230769e1dda94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr class="memitem:a7f0b005ed1ecf779b19b3c7e86ebae5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a7f0b005ed1ecf779b19b3c7e86ebae5f">get</a> (std::string const &amp;key) const </td></tr>
<tr class="memdesc:a7f0b005ed1ecf779b19b3c7e86ebae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of an entry in the cache, provided the entry has not expired.  <a href="#a7f0b005ed1ecf779b19b3c7e86ebae5f">More...</a><br /></td></tr>
<tr class="separator:a7f0b005ed1ecf779b19b3c7e86ebae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493d014368f226c3e52267da5ccf7a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; <a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a493d014368f226c3e52267da5ccf7a61">get_data</a> (std::string const &amp;key) const </td></tr>
<tr class="memdesc:a493d014368f226c3e52267da5ccf7a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data for an entry in the cache, provided the entry has not expired.  <a href="#a493d014368f226c3e52267da5ccf7a61">More...</a><br /></td></tr>
<tr class="separator:a493d014368f226c3e52267da5ccf7a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e49006c8847ee36b9fbca76877d269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#ab6e49006c8847ee36b9fbca76877d269">get_metadata</a> (std::string const &amp;key) const </td></tr>
<tr class="memdesc:ab6e49006c8847ee36b9fbca76877d269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the metadata for an entry in the cache, provided the entry has not expired.  <a href="#ab6e49006c8847ee36b9fbca76877d269">More...</a><br /></td></tr>
<tr class="separator:ab6e49006c8847ee36b9fbca76877d269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ce29e842aa9ab43813d9bdcaffa447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a78ce29e842aa9ab43813d9bdcaffa447">contains_key</a> (std::string const &amp;key) const </td></tr>
<tr class="memdesc:a78ce29e842aa9ab43813d9bdcaffa447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if an (unexpired) entry is in the cache.  <a href="#a78ce29e842aa9ab43813d9bdcaffa447">More...</a><br /></td></tr>
<tr class="separator:a78ce29e842aa9ab43813d9bdcaffa447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66543832aa2a665d40bff3c1ffc16fce"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a66543832aa2a665d40bff3c1ffc16fce">size</a> () const noexcept</td></tr>
<tr class="memdesc:a66543832aa2a665d40bff3c1ffc16fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the cache.  <a href="#a66543832aa2a665d40bff3c1ffc16fce">More...</a><br /></td></tr>
<tr class="separator:a66543832aa2a665d40bff3c1ffc16fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e3ddec329ecda178dfcae97bf2624a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a92e3ddec329ecda178dfcae97bf2624a">size_in_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a92e3ddec329ecda178dfcae97bf2624a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes consumed by entries in the cache.  <a href="#a92e3ddec329ecda178dfcae97bf2624a">More...</a><br /></td></tr>
<tr class="separator:a92e3ddec329ecda178dfcae97bf2624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5437e0288bcdebaa649d74c1f5edb759"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a5437e0288bcdebaa649d74c1f5edb759">max_size_in_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a5437e0288bcdebaa649d74c1f5edb759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum size of the cache in bytes.  <a href="#a5437e0288bcdebaa649d74c1f5edb759">More...</a><br /></td></tr>
<tr class="separator:a5437e0288bcdebaa649d74c1f5edb759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef11f5de0b492f266026101df21853e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#abef11f5de0b492f266026101df21853e">disk_size_in_bytes</a> () const </td></tr>
<tr class="memdesc:abef11f5de0b492f266026101df21853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the disk space consumed by the cache.  <a href="#abef11f5de0b492f266026101df21853e">More...</a><br /></td></tr>
<tr class="separator:abef11f5de0b492f266026101df21853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18521f3f3ce9ec1fb076fc8b37819a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#a2e77cb6543f624a64853a66237d75c2b">CacheDiscardPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a18521f3f3ce9ec1fb076fc8b37819a0a">discard_policy</a> () const noexcept</td></tr>
<tr class="memdesc:a18521f3f3ce9ec1fb076fc8b37819a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the discard policy of the cache.  <a href="#a18521f3f3ce9ec1fb076fc8b37819a0a">More...</a><br /></td></tr>
<tr class="separator:a18521f3f3ce9ec1fb076fc8b37819a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514ede17d1d029b2401f744a436eb8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore_1_1PersistentCacheStats.html">PersistentCacheStats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a514ede17d1d029b2401f744a436eb8d7">stats</a> () const </td></tr>
<tr class="memdesc:a514ede17d1d029b2401f744a436eb8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statistics for the cache.  <a href="#a514ede17d1d029b2401f744a436eb8d7">More...</a><br /></td></tr>
<tr class="separator:a514ede17d1d029b2401f744a436eb8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation Methods</div></td></tr>
<tr class="memitem:ac856ad6d54e1af71a10074a6bb57377d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">UPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#ac856ad6d54e1af71a10074a6bb57377d">open</a> (std::string const &amp;cache_path, int64_t <a class="el" href="classcore_1_1PersistentStringCache.html#a5437e0288bcdebaa649d74c1f5edb759">max_size_in_bytes</a>, <a class="el" href="namespacecore.html#a2e77cb6543f624a64853a66237d75c2b">CacheDiscardPolicy</a> policy)</td></tr>
<tr class="memdesc:ac856ad6d54e1af71a10074a6bb57377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates or opens a <a class="el" href="classcore_1_1PersistentStringCache.html" title="A cache of key-value pairs with persistent storage. ">PersistentStringCache</a>.  <a href="#ac856ad6d54e1af71a10074a6bb57377d">More...</a><br /></td></tr>
<tr class="separator:ac856ad6d54e1af71a10074a6bb57377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c43c8a7bcbc24702f7f77f29e5911"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">UPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#ad20c43c8a7bcbc24702f7f77f29e5911">open</a> (std::string const &amp;cache_path)</td></tr>
<tr class="memdesc:ad20c43c8a7bcbc24702f7f77f29e5911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing <a class="el" href="classcore_1_1PersistentStringCache.html" title="A cache of key-value pairs with persistent storage. ">PersistentStringCache</a>.  <a href="#ad20c43c8a7bcbc24702f7f77f29e5911">More...</a><br /></td></tr>
<tr class="separator:ad20c43c8a7bcbc24702f7f77f29e5911"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Modifiers</h2></td></tr>
<tr class="memitem:af9e4d126ce98ec8ab7d5a54d06156129"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::string const &amp;key, <a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;cache)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">Loader</a></td></tr>
<tr class="memdesc:af9e4d126ce98ec8ab7d5a54d06156129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by the cache to load an entry after a cache miss.  <a href="#af9e4d126ce98ec8ab7d5a54d06156129">More...</a><br /></td></tr>
<tr class="separator:af9e4d126ce98ec8ab7d5a54d06156129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07df774656e930971c03e8c6431faf0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a07df774656e930971c03e8c6431faf0a">put</a> (std::string const &amp;key, std::string const &amp;value, std::chrono::time_point&lt; std::chrono::system_clock &gt; expiry_time=std::chrono::system_clock::time_point())</td></tr>
<tr class="memdesc:a07df774656e930971c03e8c6431faf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates an entry.  <a href="#a07df774656e930971c03e8c6431faf0a">More...</a><br /></td></tr>
<tr class="separator:a07df774656e930971c03e8c6431faf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a13cba3fe14699189bc3445d5e1bf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a42a13cba3fe14699189bc3445d5e1bf8">put</a> (std::string const &amp;key, char const *value, int64_t <a class="el" href="classcore_1_1PersistentStringCache.html#a66543832aa2a665d40bff3c1ffc16fce">size</a>, std::chrono::time_point&lt; std::chrono::system_clock &gt; expiry_time=std::chrono::system_clock::time_point())</td></tr>
<tr class="memdesc:a42a13cba3fe14699189bc3445d5e1bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates an entry.  <a href="#a42a13cba3fe14699189bc3445d5e1bf8">More...</a><br /></td></tr>
<tr class="separator:a42a13cba3fe14699189bc3445d5e1bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da63986f191b9205bc92d011801f6ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a2da63986f191b9205bc92d011801f6ec">put</a> (std::string const &amp;key, std::string const &amp;value, std::string const &amp;metadata, std::chrono::time_point&lt; std::chrono::system_clock &gt; expiry_time=std::chrono::system_clock::time_point())</td></tr>
<tr class="memdesc:a2da63986f191b9205bc92d011801f6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates an entry and its metadata.  <a href="#a2da63986f191b9205bc92d011801f6ec">More...</a><br /></td></tr>
<tr class="separator:a2da63986f191b9205bc92d011801f6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ea514ad20bf1bcc6e55f62a699bacd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a88ea514ad20bf1bcc6e55f62a699bacd">put</a> (std::string const &amp;key, char const *value, int64_t value_size, char const *metadata, int64_t metadata_size, std::chrono::time_point&lt; std::chrono::system_clock &gt; expiry_time=std::chrono::system_clock::time_point())</td></tr>
<tr class="memdesc:a88ea514ad20bf1bcc6e55f62a699bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates an entry and its metadata.  <a href="#a88ea514ad20bf1bcc6e55f62a699bacd">More...</a><br /></td></tr>
<tr class="separator:a88ea514ad20bf1bcc6e55f62a699bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf4537f7936547a25acccf34014bac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a4bf4537f7936547a25acccf34014bac6">get_or_put</a> (std::string const &amp;key, <a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">Loader</a> const &amp;load_func)</td></tr>
<tr class="memdesc:a4bf4537f7936547a25acccf34014bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically retrieves or stores a cache entry.  <a href="#a4bf4537f7936547a25acccf34014bac6">More...</a><br /></td></tr>
<tr class="separator:a4bf4537f7936547a25acccf34014bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2de34f503e3010943d6e231ce644ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; <a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a7b2de34f503e3010943d6e231ce644ff">get_or_put_data</a> (std::string const &amp;key, <a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">Loader</a> const &amp;load_func)</td></tr>
<tr class="memdesc:a7b2de34f503e3010943d6e231ce644ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically retrieves or stores a cache entry.  <a href="#a7b2de34f503e3010943d6e231ce644ff">More...</a><br /></td></tr>
<tr class="separator:a7b2de34f503e3010943d6e231ce644ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b5be28c5fd5523f7563927b58bdab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a61b5be28c5fd5523f7563927b58bdab9">put_metadata</a> (std::string const &amp;key, std::string const &amp;metadata)</td></tr>
<tr class="memdesc:a61b5be28c5fd5523f7563927b58bdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or replaces the metadata for an entry.  <a href="#a61b5be28c5fd5523f7563927b58bdab9">More...</a><br /></td></tr>
<tr class="separator:a61b5be28c5fd5523f7563927b58bdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7453818dec40a510ae90c1c2c82b9c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a7453818dec40a510ae90c1c2c82b9c07">put_metadata</a> (std::string const &amp;key, char const *metadata, int64_t <a class="el" href="classcore_1_1PersistentStringCache.html#a66543832aa2a665d40bff3c1ffc16fce">size</a>)</td></tr>
<tr class="memdesc:a7453818dec40a510ae90c1c2c82b9c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or replaces the metadata for an entry.  <a href="#a7453818dec40a510ae90c1c2c82b9c07">More...</a><br /></td></tr>
<tr class="separator:a7453818dec40a510ae90c1c2c82b9c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead22e435835fc5c4fc7856e88963a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#aead22e435835fc5c4fc7856e88963a92">take</a> (std::string const &amp;key)</td></tr>
<tr class="memdesc:aead22e435835fc5c4fc7856e88963a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry and returns its value.  <a href="#aead22e435835fc5c4fc7856e88963a92">More...</a><br /></td></tr>
<tr class="separator:aead22e435835fc5c4fc7856e88963a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72be60ac3e2ab8af096e754122379234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt; <a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a72be60ac3e2ab8af096e754122379234">take_data</a> (std::string const &amp;key)</td></tr>
<tr class="memdesc:a72be60ac3e2ab8af096e754122379234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry and returns its value and metadata.  <a href="#a72be60ac3e2ab8af096e754122379234">More...</a><br /></td></tr>
<tr class="separator:a72be60ac3e2ab8af096e754122379234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29edfcf75170f10650ede7b38445fd73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a29edfcf75170f10650ede7b38445fd73">invalidate</a> (std::string const &amp;key)</td></tr>
<tr class="memdesc:a29edfcf75170f10650ede7b38445fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entry and its associated metadata (if any).  <a href="#a29edfcf75170f10650ede7b38445fd73">More...</a><br /></td></tr>
<tr class="separator:a29edfcf75170f10650ede7b38445fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa19d585fed5ada80e7339d27bf95f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a8aa19d585fed5ada80e7339d27bf95f9">invalidate</a> (std::vector&lt; std::string &gt; const &amp;keys)</td></tr>
<tr class="memdesc:a8aa19d585fed5ada80e7339d27bf95f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the specified entries from the cache.  <a href="#a8aa19d585fed5ada80e7339d27bf95f9">More...</a><br /></td></tr>
<tr class="separator:a8aa19d585fed5ada80e7339d27bf95f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa401251a408fb35f03ad229a81c2dad6"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:aa401251a408fb35f03ad229a81c2dad6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#aa401251a408fb35f03ad229a81c2dad6">invalidate</a> (It begin, It end)</td></tr>
<tr class="memdesc:aa401251a408fb35f03ad229a81c2dad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the specified entries from the cache.  <a href="#aa401251a408fb35f03ad229a81c2dad6">More...</a><br /></td></tr>
<tr class="separator:aa401251a408fb35f03ad229a81c2dad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017f91c6915bd4047dd2f8c7d7ee7387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a017f91c6915bd4047dd2f8c7d7ee7387">invalidate</a> (std::initializer_list&lt; std::string &gt; const &amp;keys)</td></tr>
<tr class="memdesc:a017f91c6915bd4047dd2f8c7d7ee7387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the specified entries from the cache.  <a href="#a017f91c6915bd4047dd2f8c7d7ee7387">More...</a><br /></td></tr>
<tr class="separator:a017f91c6915bd4047dd2f8c7d7ee7387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f2b227f7f3de99e2d6035dfd75b99c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#ad5f2b227f7f3de99e2d6035dfd75b99c">invalidate</a> ()</td></tr>
<tr class="memdesc:ad5f2b227f7f3de99e2d6035dfd75b99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all entries from the cache.  <a href="#ad5f2b227f7f3de99e2d6035dfd75b99c">More...</a><br /></td></tr>
<tr class="separator:ad5f2b227f7f3de99e2d6035dfd75b99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3017ff68869eeba6ad893d29926b5240"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a3017ff68869eeba6ad893d29926b5240">touch</a> (std::string const &amp;key, std::chrono::time_point&lt; std::chrono::system_clock &gt; expiry_time=std::chrono::system_clock::time_point())</td></tr>
<tr class="memdesc:a3017ff68869eeba6ad893d29926b5240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the access time of an entry.  <a href="#a3017ff68869eeba6ad893d29926b5240">More...</a><br /></td></tr>
<tr class="separator:a3017ff68869eeba6ad893d29926b5240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01984b19ffbadac2b4e4d0f976425b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a01984b19ffbadac2b4e4d0f976425b19">clear_stats</a> ()</td></tr>
<tr class="memdesc:a01984b19ffbadac2b4e4d0f976425b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all statistics counters.  <a href="#a01984b19ffbadac2b4e4d0f976425b19">More...</a><br /></td></tr>
<tr class="separator:a01984b19ffbadac2b4e4d0f976425b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6236f133ad774a2178ee8e487aadc8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a6236f133ad774a2178ee8e487aadc8b4">resize</a> (int64_t <a class="el" href="classcore_1_1PersistentStringCache.html#a92e3ddec329ecda178dfcae97bf2624a">size_in_bytes</a>)</td></tr>
<tr class="memdesc:a6236f133ad774a2178ee8e487aadc8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the maximum size of the cache.  <a href="#a6236f133ad774a2178ee8e487aadc8b4">More...</a><br /></td></tr>
<tr class="separator:a6236f133ad774a2178ee8e487aadc8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d1c52959d95ac0e398a40e9d424b6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a64d1c52959d95ac0e398a40e9d424b6e">trim_to</a> (int64_t used_size_in_bytes)</td></tr>
<tr class="memdesc:a64d1c52959d95ac0e398a40e9d424b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expires entries.  <a href="#a64d1c52959d95ac0e398a40e9d424b6e">More...</a><br /></td></tr>
<tr class="separator:a64d1c52959d95ac0e398a40e9d424b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f682223a9b5783bfa55d4454b6763e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#af1f682223a9b5783bfa55d4454b6763e">compact</a> ()</td></tr>
<tr class="memdesc:af1f682223a9b5783bfa55d4454b6763e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts the database.  <a href="#af1f682223a9b5783bfa55d4454b6763e">More...</a><br /></td></tr>
<tr class="separator:af1f682223a9b5783bfa55d4454b6763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Monitoring cache activity</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc23978c9654524e0f98b5f3bc2f1deb1"></a>The cache allows you to register one or more callback functions that are called when the cache contents change.</p>
<dl class="section note"><dt>Note</dt><dd>Callback functions are called by the application thread that triggered the corresponding event.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not invoke operations on the cache from within a callback function. Doing so has undefined behavior. </dd></dl>
</td></tr>
<tr class="memitem:affbc35963cd7d3b3f60a4d9a9e3fe229"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::string const &amp;key, <a class="el" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da">CacheEvent</a> ev, <a class="el" href="classcore_1_1PersistentCacheStats.html">PersistentCacheStats</a> const &amp;<a class="el" href="classcore_1_1PersistentStringCache.html#a514ede17d1d029b2401f744a436eb8d7">stats</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#affbc35963cd7d3b3f60a4d9a9e3fe229">EventCallback</a></td></tr>
<tr class="memdesc:affbc35963cd7d3b3f60a4d9a9e3fe229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a handler function.  <a href="#affbc35963cd7d3b3f60a4d9a9e3fe229">More...</a><br /></td></tr>
<tr class="separator:affbc35963cd7d3b3f60a4d9a9e3fe229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454561a6e1aad3a0dcf710011c52f79b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1PersistentStringCache.html#a454561a6e1aad3a0dcf710011c52f79b">set_handler</a> (<a class="el" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da">CacheEvent</a> events, <a class="el" href="classcore_1_1PersistentStringCache.html#affbc35963cd7d3b3f60a4d9a9e3fe229">EventCallback</a> cb)</td></tr>
<tr class="memdesc:a454561a6e1aad3a0dcf710011c52f79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a handler for one or more events.  <a href="#a454561a6e1aad3a0dcf710011c52f79b">More...</a><br /></td></tr>
<tr class="separator:a454561a6e1aad3a0dcf710011c52f79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cache of key-value pairs with persistent storage. </p>
<p><a class="el" href="classcore_1_1PersistentStringCache.html" title="A cache of key-value pairs with persistent storage. ">PersistentStringCache</a> provides a cache of key-value pairs with a backing store. It is intended for caching arbitrary (possibly large) amounts of data, such as might be needed by a web browser cache. The cache scales to large numbers (hundreds of thousands) of entries and is very fast. (Typically, the performance-limiting factor is the I/O bandwidth to disk.)</p>
<p>The cache is robust in the face of crashes and power loss. After a re-start, it is guaranteed to be in a consistent state with correct data. Some number of updates that were made just prior to a power loss or kernel crash can be lost; however, if just the calling process crashes, no updates are lost.</p>
<p>A cache has a maximum size (which can be changed at any time). Once the cache reaches its maximum size, when adding an entry, the cache automatically discards enough entries to make room for the new entry.</p>
<p>Keys can be (possibly binary) strings of size &gt; 0. Values can be (possibly binary) strings including the empty string.</p>
<p>Entries maintain an access time, which is used to keep them in least-recently-used (LRU) order. In addition, entries can have an optional expiry time. (If no expiry time is specified, infinite expiry time is assumed.)</p>
<dl class="section note"><dt>Note</dt><dd>This class is thread-safe; you can call member functions from different threads without any synchronization. Thread-safety is provided for convenience, not performance. Calling concurrently into the cache from multiple threads will not yield improved performance.</dd></dl>
<h3>Discard Policy</h3>
<p>The cache provides two different discard policies, <code>lru_ttl</code> and <code>lru_only</code>.</p>
<p>For <code>lru_ttl</code>, the discard policy of the cache is to first delete all entries that have expired. If this does not free sufficient space to make room for a new entry, the cache then deletes entries in oldest to newest (LRU) order until sufficient space is available. This deletion in LRU order may delete entries that have an expiry time, but have not expired yet, as well as entries with infinite expiry time.</p>
<p>For <code>lru_only</code>, entries do not maintain an expiry time and are therefore discarded strictly in LRU order.</p>
<p>Access and expiry times are recorded with millisecond granularity. To indicate infinite expiry time, use the defaulted parameter value or <code>chrono::system_clock::time_point()</code>.</p>
<h3>Error reporting</h3>
<p>Methods throw <code>std::runtime_error</code> if the underlying database (leveldb) reports an error. If leveldb detects database corruption, the code throws <code>std::system_error</code> with with a 666 error code. To recover from this error, remove all files in the cache directory. Other errors are indicated by throwing <code>std::logic_error</code> or <code>std::invalid_argument</code> as appropriate.</p>
<h3>Additional data</h3>
<p>Besides storing key-value pairs, the cache allows you to add arbitrary extra data to each entry. This is useful, for example, to maintain metadata (such as HTTP header details) for the entries in the cache.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is not possible to distinguish between "no metadata was ever added" and "empty metadata was added and retrieved". Do not use the metadata in such a way that you rely the difference between "metadata not there" and "metadata is the empty string".</dd></dl>
<h3>Performance</h3>
<p>Some rough performance figures, taken on an Intel Ivy Bridge i7-3770K 3.5 GHz with 16 GB RAM, appear below. Records are filled with random data to make them non-compressible.</p>
<p>After filling the cache, the code performs cache lookups using random keys, with an 80% hit probability. On a miss, it inserts a new random record. This measures the typical steady-state behavior: whenever a cache miss happens, the caller fetches the data and inserts a new record into the cache.</p>
<table class="doxtable">
<tr>
<th>Setting </th><th>Value  </th></tr>
<tr>
<td>Cache size </td><td>100 MB </td></tr>
<tr>
<td># Records </td><td>~5120 </td></tr>
<tr>
<td>Record size </td><td>20 kB, normal distribution, stddev = 7000 </td></tr>
</table>
<p>Running the test With a 7200 rpm spinning disk produces:</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Value  </th></tr>
<tr>
<td>Reads </td><td>30.9 MB/sec </td></tr>
<tr>
<td>Writes </td><td>7.0 MB/sec </td></tr>
<tr>
<td>Records/sec </td><td>1995 </td></tr>
</table>
<p>Running the test With an Intel 256 GB SSD produces:</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Value  </th></tr>
<tr>
<td>Reads </td><td>112.6 MB/sec </td></tr>
<tr>
<td>Writes </td><td>25.7 MB/sec </td></tr>
<tr>
<td>Records/sec </td><td>7112 </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When benchmarking, make sure to compile in release mode. In debug mode, a number of expensive assertions are turned on.</dd>
<dd>
Also be aware that leveldb uses Snappy compression beneath the covers. This means that, if test data is simply filled with a fixed byte pattern, you will measure artificially high performance. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="affbc35963cd7d3b3f60a4d9a9e3fe229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::string const&amp; key, <a class="el" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da">CacheEvent</a> ev, <a class="el" href="classcore_1_1PersistentCacheStats.html">PersistentCacheStats</a> const&amp; <a class="el" href="classcore_1_1PersistentStringCache.html#a514ede17d1d029b2401f744a436eb8d7">stats</a>)&gt; <a class="el" href="classcore_1_1PersistentStringCache.html#affbc35963cd7d3b3f60a4d9a9e3fe229">core::PersistentStringCache::EventCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a handler function. </p>
<dl class="section note"><dt>Note</dt><dd>Callback functions are called by the application thread that triggered the corresponding event.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not invoke operations on the cache from within a callback function. Doing so has undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry. </td></tr>
    <tr><td class="paramname">ev</td><td>The event type. </td></tr>
    <tr><td class="paramname">stats</td><td>The cache statistics. Note that the <code>stats</code> parameter reflects the state of the cache <em>after</em> the corresponding event. For example, for a <code>Put</code> event, <code>stats.size_in_bytes()</code> <em>includes</em> the size of the added entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9e4d126ce98ec8ab7d5a54d06156129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::string const&amp; key, <a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a>&amp; cache)&gt; <a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">core::PersistentStringCache::Loader</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function called by the cache to load an entry after a cache miss. </p>

</div>
</div>
<a class="anchor" id="afb41596aa15b942a0be9081dd654d555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;<a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a>&gt; <a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">core::PersistentStringCache::UPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience typedef for the return type of <a class="el" href="classcore_1_1PersistentStringCache.html#ac856ad6d54e1af71a10074a6bb57377d" title="Creates or opens a PersistentStringCache. ">open()</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abae85940424012eeb9dcf18eba40f401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">core::PersistentStringCache::PersistentStringCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae01473e8dac6afc156d151dd70973d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::PersistentStringCache::PersistentStringCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acde7b9c4c9450bfe25379227e2e7ca78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::PersistentStringCache::~PersistentStringCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys the instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a01984b19ffbadac2b4e4d0f976425b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::clear_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all statistics counters. </p>

</div>
</div>
<a class="anchor" id="af1f682223a9b5783bfa55d4454b6763e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compacts the database. </p>
<p>This operation compacts the database to consume as little disk space as possible. Note that this operation can be slow. (Compacting a 100 MB cache can take around ten seconds on a machine with a spinning-platter disk.) </p>

</div>
</div>
<a class="anchor" id="a78ce29e842aa9ab43813d9bdcaffa447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::contains_key </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if an (unexpired) entry is in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry is in the cache; <code>false</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation does <em>not</em> update the access time of the entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a3017ff68869eeba6ad893d29926b5240" title="Updates the access time of an entry. ">touch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18521f3f3ce9ec1fb076fc8b37819a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#a2e77cb6543f624a64853a66237d75c2b">CacheDiscardPolicy</a> core::PersistentStringCache::discard_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the discard policy of the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The discard policy (<code>lru_only</code> or <code>lru_ttl</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="abef11f5de0b492f266026101df21853e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t core::PersistentStringCache::disk_size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an estimate of the disk space consumed by the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The approximate number of bytes used by the cache on disk. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned size may be smaller than the eventual size if there are updates to the cache that have not yet been written to disk. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f0b005ed1ecf779b19b3c7e86ebae5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;std::string&gt; core::PersistentStringCache::get </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of an entry in the cache, provided the entry has not expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved; the value of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation updates the access time of the entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a493d014368f226c3e52267da5ccf7a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;<a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a>&gt; core::PersistentStringCache::get_data </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the data for an entry in the cache, provided the entry has not expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved; the data of the entry, otherwise. If no metadata exists, <code><a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html#aaf382b3f6b3eeab532ff2d23cd3d6e6d" title="Stores the metadata of an entry. If no metadata exists for an entry, metadata is returned as the empt...">Data::metadata</a></code> is set to the empty string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation updates the access time of the entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e49006c8847ee36b9fbca76877d269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;std::string&gt; core::PersistentStringCache::get_metadata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the metadata for an entry in the cache, provided the entry has not expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved; the metadata of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation does <em>not</em> update the access time of the entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a3017ff68869eeba6ad893d29926b5240" title="Updates the access time of an entry. ">touch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4bf4537f7936547a25acccf34014bac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;std::string&gt; core::PersistentStringCache::get_or_put </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">Loader</a> const &amp;&#160;</td>
          <td class="paramname"><em>load_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically retrieves or stores a cache entry. </p>
<p><code>get_or_put</code> attempts to retrieve the value of a (non-expired) entry. If the entry can be found, it returns its value. Otherwise, it calls <code>load_func</code>, which is expected to add the entry to the cache. If the load function succeeds in adding the entry, the value added by the load function is returned. The load function is called by the application thread.</p>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved or loaded; the value of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>The load function threw an exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The load function must (synchronously) call one of the overloaded <code>put</code> methods to add a new entry for the provided key. Calling any other method on the cache from within the load function causes undefined behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation holds a lock on the cache while the load function runs. This means that, if multiple threads call into the cache, they will be blocked for the duration of the load function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b2de34f503e3010943d6e231ce644ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;<a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a>&gt; core::PersistentStringCache::get_or_put_data </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html#af9e4d126ce98ec8ab7d5a54d06156129">Loader</a> const &amp;&#160;</td>
          <td class="paramname"><em>load_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically retrieves or stores a cache entry. </p>
<p><code>get_or_put</code> attempts to retrieve the value and metadata of a (non-expired) entry. If the entry can be found, it returns its data. Otherwise, it calls <code>load_func</code>, which is expected to add the entry to the cache. If the load function succeeds in adding the entry, the data added by the load function is returned. The load function is called by the application thread.</p>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved or loaded; the value and metadata of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>The load function threw an exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The load function must (synchronously) call one of the overloaded <code>put</code> methods to add a new entry for the provided key. Calling any other method on the cache from within the load function causes undefined behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation holds a lock on the cache while the load function runs. This means that, if multiple threads call into the cache, they will be blocked for the duration of the load function. </dd></dl>

</div>
</div>
<a class="anchor" id="a29edfcf75170f10650ede7b38445fd73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::invalidate </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an entry and its associated metadata (if any). </p>
<p>If a (non-expired) entry with the given key can be found, it is removed from the cache.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was removed; <code>false</code> if the entry could not be found or was expired. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8aa19d585fed5ada80e7339d27bf95f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::invalidate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically removes the specified entries from the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>A vector of keys for the entries to be removed. If the vector is empty, this operation is a no-op. If one or more keys are empty or specify non-existent entries, they are ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa401251a408fb35f03ad229a81c2dad6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::invalidate </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically removes the specified entries from the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the first key for the entries to be removed. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to the one-beyond-the-last key for the entries to be removed.</td></tr>
  </table>
  </dd>
</dl>
<p>If the iterator range is empty, this operation is a no-op. If one or more keys are empty or specify non-existent entries, they are ignored. </p>

</div>
</div>
<a class="anchor" id="a017f91c6915bd4047dd2f8c7d7ee7387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::invalidate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically removes the specified entries from the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The keys for the entries to be removed. If <code>keys</code> is empty, this operation is a no-op. If one or more keys are empty or specify non-existent entries, they are ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5f2b227f7f3de99e2d6035dfd75b99c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all entries from the cache. </p>
<p>This operation completely empties the cache. </p><dl class="section note"><dt>Note</dt><dd>Clearing the cache also resets the statistics counters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a01984b19ffbadac2b4e4d0f976425b19" title="Resets all statistics counters. ">clear_stats()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5437e0288bcdebaa649d74c1f5edb759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t core::PersistentStringCache::max_size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum size of the cache in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of bytes that can be stored in the cache. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a6236f133ad774a2178ee8e487aadc8b4" title="Changes the maximum size of the cache. ">resize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac856ad6d54e1af71a10074a6bb57377d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">UPtr</a> core::PersistentStringCache::open </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cache_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecore.html#a2e77cb6543f624a64853a66237d75c2b">CacheDiscardPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates or opens a <a class="el" href="classcore_1_1PersistentStringCache.html" title="A cache of key-value pairs with persistent storage. ">PersistentStringCache</a>. </p>
<p>If no cache exists on disk, it will be created; otherwise, the pre-existing cache contents are used.</p>
<p>An existing cache can be opened only if <code>max_size_in_bytes</code> and <code>policy</code> have the same values they had when the cache was last closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_path</td><td>The path to a directory in which to store the cache. The contents of this directory are exlusively owned by the cache; do not create additional files or directories there. The directory need not exist when creating a new cache. </td></tr>
    <tr><td class="paramname">max_size_in_bytes</td><td>The maximum size in bytes for the cache. </td></tr>
    <tr><td class="paramname">policy</td><td>The discard policy for the cache (<code>lru_only</code> or <code>lru_ttl</code>). The discard policy cannot be changed once a cache has been created.</td></tr>
  </table>
  </dd>
</dl>
<p>The size of an entry is the sum of the sizes of its key, value, and metadata. The maximum size of the cache is the sum of the sizes of all its entries.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code>unique_ptr</code> to the instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>max_size_in_bytes</code> is &lt; 1. </td></tr>
    <tr><td class="paramname">logic_error</td><td><code>max_size_in_bytes</code> or <code>policy</code> do not match the settings of a pre-existing cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad20c43c8a7bcbc24702f7f77f29e5911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcore_1_1PersistentStringCache.html#afb41596aa15b942a0be9081dd654d555">UPtr</a> core::PersistentStringCache::open </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>cache_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing <a class="el" href="classcore_1_1PersistentStringCache.html" title="A cache of key-value pairs with persistent storage. ">PersistentStringCache</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_path</td><td>The path to a directory containing the existing cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>unique_ptr</code> to the instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a2441b85e407b9188d38607974a6a995f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a>&amp; core::PersistentStringCache::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d8b7ecf11b9954ffa0230769e1dda94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a>&amp; core::PersistentStringCache::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07df774656e930971c03e8c6431faf0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>expiry_time</em> = <code>std::chrono::system_clock::time_point()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or updates an entry. </p>
<p>If an entry with the given key does not exist in the cache, it is added (possibly evicting a number of expired and/or older entries). If the entry still exists (whether expired or not), it is updated with the new value (and possibly expiry time).</p>
<p>This operation deletes any metadata associated with the entry.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was added or updated. <code>false</code> if the policy is <code>lru_ttl</code> and <code>expiry_time</code> is in the past.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The size of the entry exceeds the maximum cache size. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The cache policy is <code>lru_only</code> and a non-infinite expiry time was provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42a13cba3fe14699189bc3445d5e1bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>expiry_time</em> = <code>std::chrono::system_clock::time_point()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or updates an entry. </p>
<dl class="section note"><dt>Note</dt><dd>This overload is provided to avoid the need to construct a string value.</dd></dl>
<p>If an entry with the given key does not exist in the cache, it is added (possibly evicting a number of expired and/or older entries). If the entry still exists (whether expired or not), it is updated with the new value (and possibly expiry time).</p>
<p>This operation deletes any metadata associated with the entry.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was added or updated. <code>false</code> if the policy is <code>lru_ttl</code> and <code>expiry_time</code> is in the past.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the first byte of the value. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the value in bytes. </td></tr>
    <tr><td class="paramname">expiry_time</td><td>The time at which the entry expires.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td><code>value</code> is <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td><code>size</code> is negative. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The size of the entry exceeds the maximum cache size. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The cache policy is <code>lru_only</code> and a non-infinite expiry time was provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2da63986f191b9205bc92d011801f6ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>expiry_time</em> = <code>std::chrono::system_clock::time_point()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or updates an entry and its metadata. </p>
<p>If an entry with the given key does not exist in the cache, it is added (possibly evicting a number of expired and/or older entries). If the entry still exists (whether expired or not), it is updated with the new value and metadata (and possibly expiry time).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was added or updated. <code>false</code> if the policy is <code>lru_ttl</code> and <code>expiry_time</code> is in the past.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The sum of sizes of the entry and metadata exceeds the maximum cache size. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The cache policy is <code>lru_only</code> and a non-infinite expiry time was provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88ea514ad20bf1bcc6e55f62a699bacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>metadata_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>expiry_time</em> = <code>std::chrono::system_clock::time_point()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or updates an entry and its metadata. </p>
<dl class="section note"><dt>Note</dt><dd>This overload is provided to avoid the need to construct strings for the value and metadata.</dd></dl>
<p>If an entry with the given key does not exist in the cache, it is added (possibly evicting a number of expired and/or older entries). If the entry still exists (whether expired or not), it is updated with the new value and metadata (and possibly expiry time).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was added or updated. <code>false</code> if the policy is <code>lru_ttl</code> and <code>expiry_time</code> is in the past.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the first byte of the value. </td></tr>
    <tr><td class="paramname">value_size</td><td>The size of the value in bytes. </td></tr>
    <tr><td class="paramname">metadata</td><td>A pointer to the first byte of the metadata. </td></tr>
    <tr><td class="paramname">metadata_size</td><td>The size of the metadata in bytes. </td></tr>
    <tr><td class="paramname">expiry_time</td><td>The time at which the entry expires.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The sum of sizes of the entry and metadata exceeds the maximum cache size. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The cache policy is <code>lru_only</code> and a non-infinite expiry time was provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61b5be28c5fd5523f7563927b58bdab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put_metadata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or replaces the metadata for an entry. </p>
<p>If a (non-expired) entry with the given key exists in the cache, its metadata is set to the provided value, replacing any previous metadata.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the metadata was added or updated. <code>false</code> if the entry could not be found or was expired.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The new size of the entry would exceed the maximum cache size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation does <em>not</em> update the access time of the entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a3017ff68869eeba6ad893d29926b5240" title="Updates the access time of an entry. ">touch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7453818dec40a510ae90c1c2c82b9c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::put_metadata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds or replaces the metadata for an entry. </p>
<dl class="section note"><dt>Note</dt><dd>This overload is provided to avoid the need to construct a string for the metadata.</dd></dl>
<p>If a (non-expired) entry with the given key exists in the cache, its metadata is set to the provided value, replacing any previous metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry. </td></tr>
    <tr><td class="paramname">metadata</td><td>A pointer to the first byte of the metadata. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the metadata in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the metadata was added or updated. <code>false</code> if the entry could not be found or was expired.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td><code>metadata</code> is <code>nullptr</code>. </td></tr>
    <tr><td class="paramname">invalid_argument</td><td><code>size</code> is negative. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The new size of the entry would exceed the maximum cache size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation does <em>not</em> update the access time of the entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a3017ff68869eeba6ad893d29926b5240" title="Updates the access time of an entry. ">touch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6236f133ad774a2178ee8e487aadc8b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::resize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the maximum size of the cache. </p>
<p>If <code>size_in_bytes</code> is greater or equal to <a class="el" href="classcore_1_1PersistentStringCache.html#a5437e0288bcdebaa649d74c1f5edb759" title="Returns the maximum size of the cache in bytes. ">max_size_in_bytes()</a>, the cache size is set to <code>size_in_bytes</code>.</p>
<p>If <code>size_in_bytes</code> is less than <a class="el" href="classcore_1_1PersistentStringCache.html#a5437e0288bcdebaa649d74c1f5edb759" title="Returns the maximum size of the cache in bytes. ">max_size_in_bytes()</a>, the cache discards existing entries until the size falls to (or below) <code>size_in_bytes</code> and sets the cache size to the new value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>size_in_bytes</code> is &lt; 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the new size is less than the current size, this operation compacts the database to use the smallest possible amount of disk space. </dd></dl>

</div>
</div>
<a class="anchor" id="a454561a6e1aad3a0dcf710011c52f79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::set_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da">CacheEvent</a>&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1PersistentStringCache.html#affbc35963cd7d3b3f60a4d9a9e3fe229">EventCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a handler for one or more events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>A bitwise OR of the event types for which to install the handler. To install a handler for all events, you can use core::AllCacheEvents.</td></tr>
    <tr><td class="paramname">cb</td><td>The handler to install. To cancel an existing handler, pass <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, to install a handler for <code>get</code> and <code>put</code> events, you could use:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cache = <a class="code" href="classcore_1_1PersistentStringCache.html#ac856ad6d54e1af71a10074a6bb57377d">PersistentStringCache::open</a>(<span class="stringliteral">&quot;my_cache&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> handler = [](<span class="keywordtype">string</span> <span class="keyword">const</span>&amp; key, <a class="code" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da">CacheEvent</a> event, PersistentCacheStats <span class="keyword">const</span>&amp; <a class="code" href="classcore_1_1PersistentStringCache.html#a514ede17d1d029b2401f744a436eb8d7">stats</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line">cache-&gt;set_handler(<a class="code" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330daab5eda0a74558a342cf659187f06f746f">CacheEvent::get</a> | <a class="code" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330daa8e13ffc9fd9d6a6761231a764bdf106b">CacheEvent::put</a>, handler);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecore.html#aca9c25d2a4df9c9a4787c58cc94330da" title="Event types that can be monitored. ">CacheEvent</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66543832aa2a665d40bff3c1ffc16fce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t core::PersistentStringCache::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of entries in the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of entries in the cache. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned count includes possibly expired entries. </dd></dl>

</div>
</div>
<a class="anchor" id="a92e3ddec329ecda178dfcae97bf2624a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t core::PersistentStringCache::size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes consumed by entries in the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes in the cache. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned size includes possibly expired entries. </dd></dl>

</div>
</div>
<a class="anchor" id="a514ede17d1d029b2401f744a436eb8d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1PersistentCacheStats.html">PersistentCacheStats</a> core::PersistentStringCache::stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns statistics for the cache. </p>
<p>The returned statistics are persistent and are restored the next time an existing cache is opened. Call <a class="el" href="classcore_1_1PersistentStringCache.html#a01984b19ffbadac2b4e4d0f976425b19" title="Resets all statistics counters. ">clear_stats()</a> to explicitly reset the statistics counters and time stamps to zero. </p><dl class="section return"><dt>Returns</dt><dd>An object that provides accessors to statistics and settings. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcore_1_1PersistentStringCache.html#a01984b19ffbadac2b4e4d0f976425b19" title="Resets all statistics counters. ">clear_stats()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aead22e435835fc5c4fc7856e88963a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;std::string&gt; core::PersistentStringCache::take </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an entry and returns its value. </p>
<p>If a (non-expired) entry with the given key can be found, it is removed from the cache and its value returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be found; the value of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72be60ac3e2ab8af096e754122379234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecore.html#afdb9bed163cd42fbf86a52f2e8f775a4">Optional</a>&lt;<a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html">Data</a>&gt; core::PersistentStringCache::take_data </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an entry and returns its value and metadata. </p>
<p>If a (non-expired) entry with the given key can be found, it is removed from the cache and its data returned. If no metadata exists, <code><a class="el" href="structcore_1_1PersistentStringCache_1_1Data.html#aaf382b3f6b3eeab532ff2d23cd3d6e6d" title="Stores the metadata of an entry. If no metadata exists for an entry, metadata is returned as the empt...">Data::metadata</a></code> is set to the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>A null value if the entry could not be retrieved; the value and metadata of the entry, otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3017ff68869eeba6ad893d29926b5240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core::PersistentStringCache::touch </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>expiry_time</em> = <code>std::chrono::system_clock::time_point()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the access time of an entry. </p>
<p>If the entry specified by <code>key</code> is still in the cache (whether expired or not), it is marked as the most-recently used entry. If the policy is <code>lru_ttl</code>, the entry's expiry time is updated with the specified time (infinite expiry by default).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the entry was updated; <code>false</code> if the entry could not be found or <code>expiry_time</code> is in the past. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td><code>key</code> is the empty string. </td></tr>
    <tr><td class="paramname">logic_error</td><td>The cache policy is <code>lru_only</code> and a non-infinite expiry time was provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64d1c52959d95ac0e398a40e9d424b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core::PersistentStringCache::trim_to </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>used_size_in_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expires entries. </p>
<p>Expires entries using the cache's expiration policy until the cache size falls to or below <code>used_size_in_bytes</code>. If <code>used_size_in_bytes</code> is less than the current cache size, this operation is a no-op.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td><code>used_size_in_bytes</code> is &lt; 0 </td></tr>
    <tr><td class="paramname">logic_error</td><td><code>used_size_in_bytes</code> is &gt; <a class="el" href="classcore_1_1PersistentStringCache.html#a5437e0288bcdebaa649d74c1f5edb759" title="Returns the maximum size of the cache in bytes. ">max_size_in_bytes()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/michi/src/persistent-cache-cpp/trunk/include/core/<a class="el" href="persistent__string__cache_8h_source.html">persistent_string_cache.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecore.html">core</a></li><li class="navelem"><a class="el" href="classcore_1_1PersistentStringCache.html">PersistentStringCache</a></li>
    <li class="footer">Generated on Tue Jul 21 2015 16:07:26 for persistent-cache-cpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
